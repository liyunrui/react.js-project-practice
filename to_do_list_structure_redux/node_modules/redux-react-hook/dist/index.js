'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
// From https://github.com/reduxjs/react-redux/blob/3e53ff96ed10f71c21346f08823e503df724db35/src/utils/shallowEqual.js
var hasOwn = Object.prototype.hasOwnProperty;
function is(x, y) {
    if (x === y) {
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
    }
    else {
        return x !== x && y !== y;
    }
}
function shallowEqual(objA, objB) {
    if (is(objA, objB)) {
        return true;
    }
    if (typeof objA !== 'object' ||
        objA === null ||
        typeof objB !== 'object' ||
        objB === null) {
        return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
        return false;
    }
    // tslint:disable-next-line:prefer-for-of
    for (var i = 0; i < keysA.length; i++) {
        if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
        }
    }
    return true;
}

// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
var MissingProviderError = /** @class */ (function (_super) {
    __extends(MissingProviderError, _super);
    function MissingProviderError() {
        return _super.call(this, 'redux-react-hook requires your Redux store to be passed through ' +
            'context via the <StoreContext.Provider>') || this;
    }
    return MissingProviderError;
}(Error));
function memoizeSingleArg(fn) {
    var value;
    var prevArg;
    return function (arg) {
        if (prevArg !== arg) {
            prevArg = arg;
            value = fn(arg);
        }
        return value;
    };
}
/**
 * To use redux-react-hook with stronger type safety, or to use with multiple
 * stores in the same app, create() your own instance and re-export the returned
 * functions.
 */
function create() {
    var StoreContext = react.createContext(null);
    /**
     * Your passed in mapState function should be memoized with useCallback to avoid
     * resubscribing every render. If you don't use other props in mapState, pass
     * an empty array [] as the dependency list so the callback isn't recreated
     * every render.
     *
     * const todo = useMappedState(useCallback(
     *   state => state.todos.get(id),
     *   [id],
     * ));
     */
    function useMappedState(mapState) {
        var store = react.useContext(StoreContext);
        if (!store) {
            throw new MissingProviderError();
        }
        // We don't keep the derived state but call mapState on every render with current state.
        // This approach guarantees that useMappedState returns up-to-date derived state.
        // Since mapState can be expensive and must be a pure function of state we memoize it.
        var memoizedMapState = react.useMemo(function () { return memoizeSingleArg(mapState); }, [
            mapState,
        ]);
        var state = store.getState();
        var derivedState = memoizedMapState(state);
        // Since we don't keep the derived state we still need to trigger
        // an update when derived state changes.
        var _a = react.useReducer(function (x) { return x + 1; }, 0), forceUpdate = _a[1];
        // Keep previously commited derived state in a ref. Compare it to the new
        // one when an action is dispatched and call forceUpdate if they are different.
        var lastStateRef = react.useRef(derivedState);
        var memoizedMapStateRef = react.useRef(memoizedMapState);
        react.useEffect(function () {
            lastStateRef.current = derivedState;
            memoizedMapStateRef.current = memoizedMapState;
        });
        react.useEffect(function () {
            var didUnsubscribe = false;
            // Run the mapState callback and if the result has changed, make the
            // component re-render with the new state.
            var checkForUpdates = function () {
                if (didUnsubscribe) {
                    // Don't run stale listeners.
                    // Redux doesn't guarantee unsubscriptions happen until next dispatch.
                    return;
                }
                var newDerivedState = memoizedMapStateRef.current(store.getState());
                if (!shallowEqual(newDerivedState, lastStateRef.current)) {
                    // In TS definitions userReducer's dispatch requires an argument
                    forceUpdate();
                }
            };
            // Pull data from the store after first render in case the store has
            // changed since we began.
            checkForUpdates();
            // Subscribe to the store to be notified of subsequent changes.
            var unsubscribe = store.subscribe(checkForUpdates);
            // The return value of useEffect will be called when unmounting, so
            // we use it to unsubscribe from the store.
            return function () {
                didUnsubscribe = true;
                unsubscribe();
            };
        }, [store]);
        return derivedState;
    }
    function useDispatch() {
        var store = react.useContext(StoreContext);
        if (!store) {
            throw new MissingProviderError();
        }
        return store.dispatch;
    }
    return {
        StoreContext: StoreContext,
        useDispatch: useDispatch,
        useMappedState: useMappedState,
    };
}

// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
var _a;
var StoreContext = (_a = create(), _a.StoreContext), useDispatch = _a.useDispatch, useMappedState = _a.useMappedState;

exports.StoreContext = StoreContext;
exports.useDispatch = useDispatch;
exports.useMappedState = useMappedState;
exports.create = create;
//# sourceMappingURL=index.js.map
